# -*- coding: utf-8 -*-
"""聚焦肿瘤诊断

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1a_3HGAe9RzK78kgM9WiIYKmNDM5lOHlG
"""

!pip install SimpleITK
!pip install monai

!pip install trimesh

!pip install scikit-learn

import SimpleITK as sitk
import torch
import numpy as np
from monai.networks.nets import UNet

# 创建虚拟的 NIfTI 文件
def create_fake_image():
    data = np.random.randint(0, 256, (64, 64, 64), dtype=np.uint8)
    image = sitk.GetImageFromArray(data)
    sitk.WriteImage(image, 'fake_lung_ct.nii.gz')
    return 'fake_lung_ct.nii.gz'

# 加载CT影像
def load_image(image_path):
    image = sitk.ReadImage(image_path)
    return image

# 使用MONAI的预训练UNet模型进行分割
def segment_tumor(image):
    model = UNet(spatial_dims=3, in_channels=1, out_channels=2, channels=(16, 32, 64), strides=(2, 2, 2))

    # 将SimpleITK图像转换为PyTorch张量
    image_tensor = torch.tensor(sitk.GetArrayFromImage(image)).unsqueeze(0).unsqueeze(0).float()

    # 使用UNet模型进行肿瘤分割
    with torch.no_grad():
        output = model(image_tensor)
    seg = output.argmax(dim=1)  # 选择分割的肿瘤区域
    return seg

# 创建并加载虚拟文件
fake_image_path = create_fake_image()
image = load_image(fake_image_path)
segmented_image = segment_tumor(image)

# 你可以打印或查看分割结果
print(segmented_image)

from skimage.measure import marching_cubes
import trimesh
import numpy as np
import SimpleITK as sitk
import torch
from monai.networks.nets import UNet

# 创建虚拟的 NIfTI 文件
def create_fake_image():
    data = np.random.randint(0, 256, (64, 64, 64), dtype=np.uint8)
    image = sitk.GetImageFromArray(data)
    sitk.WriteImage(image, 'fake_lung_ct.nii.gz')
    return 'fake_lung_ct.nii.gz'

# 加载CT影像
def load_image(image_path):
    image = sitk.ReadImage(image_path)
    return image

# 使用MONAI的预训练UNet模型进行分割
def segment_tumor(image):
    model = UNet(spatial_dims=3, in_channels=1, out_channels=2, channels=(16, 32, 64), strides=(2, 2, 2))

    # 将SimpleITK图像转换为PyTorch张量
    image_tensor = torch.tensor(sitk.GetArrayFromImage(image)).unsqueeze(0).unsqueeze(0).float()

    # 使用UNet模型进行肿瘤分割
    with torch.no_grad():
        output = model(image_tensor)
    seg = output.argmax(dim=1)  # 选择分割的肿瘤区域

    # 确保输出是三维 NumPy 数组
    seg_array = seg.squeeze().numpy()

    return seg_array

# 使用Marching Cubes进行表面重建
def reconstruct_surface(segmentation):
    verts, faces, _, _ = marching_cubes(segmentation, level=0.5)  # 创建三角网格
    return verts, faces

# 计算离散高斯曲率
def compute_curvature(verts, faces, radius=1.0):
    mesh = trimesh.Trimesh(vertices=verts, faces=faces)
    curvatures = trimesh.curvature.discrete_gaussian_curvature_measure(mesh, verts, radius)
    return curvatures

# 创建并加载虚拟文件
fake_image_path = create_fake_image()
image = load_image(fake_image_path)
segmented_image = segment_tumor(image)

# 计算表面并计算曲率
verts, faces = reconstruct_surface(segmented_image)
curvatures = compute_curvature(verts, faces)

# 你可以打印或查看结果
print("Vertices:", verts)
print("Faces:", faces)
print("Curvatures:", curvatures)

from skimage.measure import marching_cubes
import trimesh
import numpy as np
import SimpleITK as sitk
import torch
from monai.networks.nets import UNet

# 创建虚拟的 NIfTI 文件
def create_fake_image():
    data = np.random.randint(0, 256, (64, 64, 64), dtype=np.uint8)
    image = sitk.GetImageFromArray(data)
    sitk.WriteImage(image, 'fake_lung_ct.nii.gz')
    return 'fake_lung_ct.nii.gz'

# 加载CT影像
def load_image(image_path):
    image = sitk.ReadImage(image_path)
    return image

# 使用MONAI的预训练UNet模型进行分割
def segment_tumor(image):
    model = UNet(spatial_dims=3, in_channels=1, out_channels=2, channels=(16, 32, 64), strides=(2, 2, 2))

    # 将SimpleITK图像转换为PyTorch张量
    image_tensor = torch.tensor(sitk.GetArrayFromImage(image)).unsqueeze(0).unsqueeze(0).float()

    # 使用UNet模型进行肿瘤分割
    with torch.no_grad():
        output = model(image_tensor)
    seg = output.argmax(dim=1)  # 选择分割的肿瘤区域

    # 确保输出是三维 NumPy 数组
    seg_array = seg.squeeze().numpy()

    return seg_array

# 使用Marching Cubes进行表面重建
def reconstruct_surface(segmentation):
    verts, faces, _, _ = marching_cubes(segmentation, level=0.5)  # 创建三角网格
    return verts, faces

# 计算离散高斯曲率
def compute_curvature(verts, faces, radius=1.0):
    mesh = trimesh.Trimesh(vertices=verts, faces=faces)
    curvatures = trimesh.curvature.discrete_gaussian_curvature_measure(mesh, verts, radius)
    return curvatures

# 计算拓扑分型评分
def compute_topological_score(curvatures, mask_volume):
    high_risk = curvatures > 0.1  # 设定曲率阈值
    high_risk_volume = np.sum(high_risk) * 1  # 假设体素体积为1（实际需要根据数据调整）
    score = (high_risk_volume / mask_volume) * np.max(curvatures)
    return score

# 创建并加载虚拟文件
fake_image_path = create_fake_image()
image = load_image(fake_image_path)
segmented_image = segment_tumor(image)

# 计算表面并计算曲率
verts, faces = reconstruct_surface(segmented_image)
curvatures = compute_curvature(verts, faces)

# 假设mask_volume为肿瘤总体积
mask_volume = np.prod(segmented_image.shape)  # 这里是一个简化的假设
topological_score = compute_topological_score(curvatures, mask_volume)

# 打印结果
print("Vertices:", verts)
print("Faces:", faces)
print("Curvatures:", curvatures)
print(f"Topological Score: {topological_score}")

from skimage.measure import marching_cubes
import trimesh
import numpy as np
import SimpleITK as sitk
import torch
from monai.networks.nets import UNet
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import roc_auc_score

# 创建虚拟的 NIfTI 文件
def create_fake_image():
    data = np.random.randint(0, 256, (64, 64, 64), dtype=np.uint8)
    image = sitk.GetImageFromArray(data)
    sitk.WriteImage(image, 'fake_lung_ct.nii.gz')
    return 'fake_lung_ct.nii.gz'

# 加载CT影像
def load_image(image_path):
    image = sitk.ReadImage(image_path)
    return image

# 使用MONAI的预训练UNet模型进行分割
def segment_tumor(image):
    model = UNet(spatial_dims=3, in_channels=1, out_channels=2, channels=(16, 32, 64), strides=(2, 2, 2))

    # 将SimpleITK图像转换为PyTorch张量
    image_tensor = torch.tensor(sitk.GetArrayFromImage(image)).unsqueeze(0).unsqueeze(0).float()

    # 使用UNet模型进行肿瘤分割
    with torch.no_grad():
        output = model(image_tensor)
    seg = output.argmax(dim=1)  # 选择分割的肿瘤区域

    # 确保输出是三维 NumPy 数组
    seg_array = seg.squeeze().numpy()

    return seg_array

# 使用Marching Cubes进行表面重建
def reconstruct_surface(segmentation):
    verts, faces, _, _ = marching_cubes(segmentation, level=0.5)  # 创建三角网格
    return verts, faces

# 计算离散高斯曲率
def compute_curvature(verts, faces, radius=1.0):
    mesh = trimesh.Trimesh(vertices=verts, faces=faces)
    curvatures = trimesh.curvature.discrete_gaussian_curvature_measure(mesh, verts, radius)
    return curvatures

# 计算拓扑分型评分
def compute_topological_score(curvatures, mask_volume):
    high_risk = curvatures > 0.1  # 设定曲率阈值
    high_risk_volume = np.sum(high_risk) * 1  # 假设体素体积为1（实际需要根据数据调整）
    score = (high_risk_volume / mask_volume) * np.max(curvatures)
    return score

# 基于S_topo评分和最大曲率进行恶性预测
def predict_malignancy(topological_score, max_curvature):
    # 创建一些假数据
    X_train = np.array([
        [topological_score, max_curvature],
        [topological_score * 0.8, max_curvature * 0.8]
    ])
    y_train = np.array([1, 0])  # 假设有一个高危样本和一个低危样本

    # 创建特征矩阵
    X_test = np.array([[topological_score, max_curvature]])

    # 训练Logistic Regression模型
    model = LogisticRegression()
    model.fit(X_train, y_train)

    # 预测恶性概率
    y_pred = model.predict_proba(X_test)[:, 1]  # 获取恶性概率
    return y_pred

# 创建并加载虚拟文件
fake_image_path = create_fake_image()
image = load_image(fake_image_path)
segmented_image = segment_tumor(image)

# 计算表面并计算曲率
verts, faces = reconstruct_surface(segmented_image)
curvatures = compute_curvature(verts, faces)

# 假设mask_volume为肿瘤总体积
mask_volume = np.prod(segmented_image.shape)  # 这里是一个简化的假设
topological_score = compute_topological_score(curvatures, mask_volume)

# 预测恶性
max_curvature = np.max(curvatures)  # 最大曲率值
malignancy_prediction = predict_malignancy(topological_score, max_curvature)

# 打印结果
print("Vertices:", verts)
print("Faces:", faces)
print("Curvatures:", curvatures)
print(f"Topological Score: {topological_score}")
print(f"Malignancy Prediction Probability: {malignancy_prediction[0]}")

from skimage.measure import marching_cubes
import trimesh
import numpy as np
import SimpleITK as sitk
import torch
from monai.networks.nets import UNet
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import roc_auc_score
import matplotlib.pyplot as plt

# 创建虚拟的 NIfTI 文件
def create_fake_image():
    data = np.random.randint(0, 256, (64, 64, 64), dtype=np.uint8)
    image = sitk.GetImageFromArray(data)
    sitk.WriteImage(image, 'fake_lung_ct.nii.gz')
    return 'fake_lung_ct.nii.gz'

# 加载CT影像
def load_image(image_path):
    image = sitk.ReadImage(image_path)
    return image

# 使用MONAI的预训练UNet模型进行分割
def segment_tumor(image):
    model = UNet(spatial_dims=3, in_channels=1, out_channels=2, channels=(16, 32, 64), strides=(2, 2, 2))

    # 将SimpleITK图像转换为PyTorch张量
    image_tensor = torch.tensor(sitk.GetArrayFromImage(image)).unsqueeze(0).unsqueeze(0).float()

    # 使用UNet模型进行肿瘤分割
    with torch.no_grad():
        output = model(image_tensor)
    seg = output.argmax(dim=1)  # 选择分割的肿瘤区域

    # 确保输出是三维 NumPy 数组
    seg_array = seg.squeeze().numpy()

    return seg_array

# 使用Marching Cubes进行表面重建
def reconstruct_surface(segmentation):
    verts, faces, _, _ = marching_cubes(segmentation, level=0.5)  # 创建三角网格
    return verts, faces

# 计算离散高斯曲率
def compute_curvature(verts, faces, radius=1.0):
    mesh = trimesh.Trimesh(vertices=verts, faces=faces)
    curvatures = trimesh.curvature.discrete_gaussian_curvature_measure(mesh, verts, radius)
    return curvatures

# 计算拓扑分型评分
def compute_topological_score(curvatures, mask_volume):
    high_risk = curvatures > 0.1  # 设定曲率阈值
    high_risk_volume = np.sum(high_risk) * 1  # 假设体素体积为1（实际需要根据数据调整）
    score = (high_risk_volume / mask_volume) * np.max(curvatures)
    return score

# 基于S_topo评分和最大曲率进行恶性预测
def predict_malignancy(topological_score, max_curvature):
    # 创建一些假数据
    X_train = np.array([
        [topological_score, max_curvature],
        [topological_score * 0.8, max_curvature * 0.8]
    ])
    y_train = np.array([1, 0])  # 假设有一个高危样本和一个低危样本

    # 创建特征矩阵
    X_test = np.array([[topological_score, max_curvature]])

    # 训练Logistic Regression模型
    model = LogisticRegression()
    model.fit(X_train, y_train)

    # 预测恶性概率
    y_pred = model.predict_proba(X_test)[:, 1]  # 获取恶性概率
    return y_pred

# 创建并加载虚拟文件
fake_image_path = create_fake_image()
image = load_image(fake_image_path)
segmented_image = segment_tumor(image)

# 计算表面并计算曲率
verts, faces = reconstruct_surface(segmented_image)
curvatures = compute_curvature(verts, faces)

# 假设mask_volume为肿瘤总体积
mask_volume = np.prod(segmented_image.shape)  # 这里是一个简化的假设
topological_score = compute_topological_score(curvatures, mask_volume)

# 预测恶性
max_curvature = np.max(curvatures)  # 最大曲率值
malignancy_prediction = predict_malignancy(topological_score, max_curvature)

# 打印结果
print("Vertices:", verts)
print("Faces:", faces)
print("Curvatures:", curvatures)
print(f"Topological Score: {topological_score}")
print(f"Malignancy Prediction Probability: {malignancy_prediction[0]}")

# 数据可视化
# 显示分割结果
plt.imshow(segmented_image[0], cmap="gray")
plt.title("Tumor Segmentation")
plt.show()

# 可视化曲率分布
plt.hist(curvatures, bins=30, color="blue", edgecolor="black")
plt.title("Curvature Distribution")
plt.xlabel("Curvature Value")
plt.ylabel("Frequency")
plt.show()

from skimage.measure import marching_cubes
import trimesh
import numpy as np
import SimpleITK as sitk
import torch
from monai.networks.nets import UNet
from sklearn.svm import SVC
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import roc_auc_score
import matplotlib.pyplot as plt

# 创建虚拟的 NIfTI 文件
def create_fake_image():
    data = np.random.randint(0, 256, (64, 64, 64), dtype=np.uint8)
    image = sitk.GetImageFromArray(data)
    sitk.WriteImage(image, 'fake_lung_ct.nii.gz')
    return 'fake_lung_ct.nii.gz'

# 加载CT影像
def load_image(image_path):
    image = sitk.ReadImage(image_path)
    return image

# 使用MONAI的预训练UNet模型进行分割
def segment_tumor(image):
    model = UNet(spatial_dims=3, in_channels=1, out_channels=2, channels=(16, 32, 64), strides=(2, 2, 2))

    # 将SimpleITK图像转换为PyTorch张量
    image_tensor = torch.tensor(sitk.GetArrayFromImage(image)).unsqueeze(0).unsqueeze(0).float()

    # 使用UNet模型进行肿瘤分割
    with torch.no_grad():
        output = model(image_tensor)
    seg = output.argmax(dim=1)  # 选择分割的肿瘤区域

    # 确保输出是三维 NumPy 数组
    seg_array = seg.squeeze().numpy()

    return seg_array

# 使用Marching Cubes进行表面重建
def reconstruct_surface(segmentation):
    verts, faces, _, _ = marching_cubes(segmentation, level=0.5)  # 创建三角网格
    return verts, faces

# 计算离散高斯曲率
def compute_curvature(verts, faces, radius=1.0):
    mesh = trimesh.Trimesh(vertices=verts, faces=faces)
    curvatures = trimesh.curvature.discrete_gaussian_curvature_measure(mesh, verts, radius)
    return curvatures

# 计算拓扑分型评分
def compute_topological_score(curvatures, mask_volume):
    high_risk = curvatures > 0.1  # 设定曲率阈值
    high_risk_volume = np.sum(high_risk) * 1  # 假设体素体积为1（实际需要根据数据调整）
    score = (high_risk_volume / mask_volume) * np.max(curvatures)
    return score

# 基于S_topo评分和最大曲率进行恶性预测（SVM）
def predict_with_svm(topological_score, max_curvature):
    # 创建一些假数据
    X_train = np.array([
        [topological_score, max_curvature],
        [topological_score * 0.8, max_curvature * 0.8]
    ])
    y_train = np.array([1, 0])  # 假设有一个高危样本和一个低危样本

    # 创建特征矩阵
    X_test = np.array([[topological_score, max_curvature]])

    # 训练SVM模型
    model = SVC(probability=True)
    model.fit(X_train, y_train)

    # 预测恶性概率
    y_pred = model.predict_proba(X_test)[:, 1]  # 获取恶性概率
    return y_pred

# 基于S_topo评分和最大曲率进行恶性预测（Random Forest）
def predict_with_rf(topological_score, max_curvature):
    # 创建一些假数据
    X_train = np.array([
        [topological_score, max_curvature],
        [topological_score * 0.8, max_curvature * 0.8]
    ])
    y_train = np.array([1, 0])  # 假设有一个高危样本和一个低危样本

    # 创建特征矩阵
    X_test = np.array([[topological_score, max_curvature]])

    # 训练Random Forest模型
    model = RandomForestClassifier()
    model.fit(X_train, y_train)

    # 预测恶性概率
    y_pred = model.predict_proba(X_test)[:, 1]  # 获取恶性概率
    return y_pred

# 创建并加载虚拟文件
fake_image_path = create_fake_image()
image = load_image(fake_image_path)
segmented_image = segment_tumor(image)

# 计算表面并计算曲率
verts, faces = reconstruct_surface(segmented_image)
curvatures = compute_curvature(verts, faces)

# 假设mask_volume为肿瘤总体积
mask_volume = np.prod(segmented_image.shape)  # 这里是一个简化的假设
topological_score = compute_topological_score(curvatures, mask_volume)

# 预测恶性
max_curvature = np.max(curvatures)  # 最大曲率值
svm_prediction = predict_with_svm(topological_score, max_curvature)
rf_prediction = predict_with_rf(topological_score, max_curvature)

# 打印结果
print("Vertices:", verts)
print("Faces:", faces)
print("Curvatures:", curvatures)
print(f"Topological Score: {topological_score}")
print(f"SVM Malignancy Prediction: {svm_prediction[0]}")
print(f"Random Forest Malignancy Prediction: {rf_prediction[0]}")

# 数据可视化
# 显示分割结果
plt.imshow(segmented_image[0], cmap="gray")
plt.title("Tumor Segmentation")
plt.show()

# 可视化曲率分布
plt.hist(curvatures, bins=30, color="blue", edgecolor="black")
plt.title("Curvature Distribution")
plt.xlabel("Curvature Value")
plt.ylabel("Frequency")
plt.show()